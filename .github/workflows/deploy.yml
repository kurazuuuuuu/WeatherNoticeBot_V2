name: 自動デプロイ

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  deploy:
    runs-on: self-hosted
    
    steps:
    - name: 1. リポジトリをチェックアウト
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: 2. Docker環境の確認 (sudoなし)
      run: |
        echo "🐳 Docker環境を確認します..."
        # 前提: このワークフローを実行する前に、セルフホステッドランナー上で
        # Dockerサービスが起動している必要があります。
        # 事前設定例: `sudo systemctl enable --now docker`
        
        # Dockerコマンドがsudoなしで実行できるかテスト
        if ! docker info > /dev/null 2>&1; then
          echo "⚠️ Dockerコマンドの実行に失敗しました。ランナーのセットアップを確認してください。"
          echo "推奨: ランナーユーザーを 'docker' グループに追加し、再ログインしてください。"
          echo "参考コマンド: sudo usermod -aG docker $(whoami)"
          exit 1
        fi
        
        echo "✅ Dockerは正常に動作しています。"
        docker --version
        docker compose version

    - name: 3. ホスト側ボリュームディレクトリの確認 (sudoなし)
      run: |
        echo "📦 ホスト側のボリュームディレクトリの権限を確認します..."
        # 前提: このワークフローを実行する前に、セルフホステッドランナー上で
        # ボリュームとして使用するディレクトリの権限が正しく設定されている必要があります。
        # 権限が正しくないと、コンテナ起動後に書き込みエラーが発生する可能性があります。
        
        # ディレクトリが存在しない場合は作成します。
        mkdir -p ./logs ./data
        
        echo "推奨される手動での事前設定コマンド例:"
        echo "  sudo chown -R 1000:1000 ./logs ./data"
        echo "  sudo chmod -R 775 ./logs ./data"
        echo "上記のコマンドは、コンテナ内のユーザー(UID:1000)が書き込みを行えるようにするためのものです。"

    - name: 4. 環境変数ファイル (.env) の生成
      run: |
        echo "🔑 シークレットから .env ファイルを生成します..."
        # heredocを使用して、よりクリーンにファイルを生成
        cat << EOF > .env
        DISCORD_TOKEN=${{ secrets.DISCORD_TOKEN }}
        DISCORD_GUILD_ID=${{ secrets.DISCORD_GUILD_ID }}
        GEMINI_API_KEY=${{ secrets.GEMINI_API_KEY }}
        # --- 必要に応じて以下のコメントを解除してください ---
        # DATABASE_URL=${{ secrets.DATABASE_URL }}
        # COMMAND_PREFIX=${{ secrets.COMMAND_PREFIX }}
        # DEFAULT_TIMEZONE=${{ secrets.DEFAULT_TIMEZONE }}
        # NOTIFICATION_RETRY_ATTEMPTS=${{ secrets.NOTIFICATION_RETRY_ATTEMPTS }}
        # NOTIFICATION_RETRY_DELAY=${{ secrets.NOTIFICATION_RETRY_DELAY }}
        # JMA_API_RATE_LIMIT=${{ secrets.JMA_API_RATE_LIMIT }}
        # GEMINI_API_RATE_LIMIT=${{ secrets.GEMINI_API_RATE_LIMIT }}
        # LOG_LEVEL=${{ secrets.LOG_LEVEL }}
        # LOG_FILE=${{ secrets.LOG_FILE }}
        # POSTGRES_DB=${{ secrets.POSTGRES_DB }}
        # POSTGRES_USER=${{ secrets.POSTGRES_USER }}
        # POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
        EOF
        echo "✅ .env ファイルが正常に生成されました。"

    - name: 5. 既存のコンテナを停止・削除
      run: |
        echo "🧹 既存のコンテナを停止・削除します..."
        # --remove-orphans で、docker-compose.yml に定義されなくなったコンテナも削除
        docker compose down --remove-orphans
    
    - name: 6. Dockerイメージをビルド
      run: |
        echo "🛠️ Dockerイメージをビルドします (キャッシュを活用)..."
        # --no-cache は削除し、Dockerのキャッシュ機能を最大限に活用
        # これにより、変更がない部分の再ビルドをスキップし、時間を大幅に短縮
        docker compose build
    
    - name: 7. アプリケーションを起動
      run: |
        echo "🚀 アプリケーションをバックグラウンドで起動します..."
        docker compose up -d
    
    - name: 8. ヘルスチェックによる起動確認
      run: |
        echo "🩺 アプリケーションの起動状態をヘルスチェックで確認します..."
        max_attempts=30
        interval=10 # 秒
        
        for i in $(seq 1 $max_attempts); do
          # docker inspect から直接ヘルスステータスを取得。コンテナが存在しない場合も考慮。
          health_status=$(docker inspect --format '{{.State.Health.Status}}' weather-bot 2>/dev/null)
          
          if [ "$health_status" = "healthy" ]; then
            echo "✅ (試行 $i/$max_attempts) アプリケーションは正常に起動しました！(Status: $health_status)"
            docker compose ps
            echo "--- 直近のログ ---"
            docker compose logs --tail=50 weather-bot
            break
          fi
          
          # コンテナが起動していない場合はエラー
          container_state=$(docker inspect --format '{{.State.Status}}' weather-bot 2>/dev/null)
          if [ "$container_state" != "running" ]; then
             # 表示用のコンテナ状態を設定 (構文エラー回避のため)
             display_state=$container_state
             if [ -z "$container_state" ]; then
               display_state="not found"
             fi
             echo "❌ (試行 $i/$max_attempts) コンテナが起動していません (State: $display_state)。"
             docker compose logs weather-bot
             exit 1
          fi

          # 表示用のヘルスステータスを設定 (構文エラー回避のため)
          display_status=$health_status
          if [ -z "$health_status" ]; then
            display_status="starting"
          fi

          # GitHub Actionsの構文エラーを避けるため、${...} を使わない形で出力
          echo "⏳ (試行 $i/$max_attempts) 起動を待機中... (Status: $display_status, Interval: ${interval}s)"
          sleep $interval
        done
        
        # ループ終了後、最終確認
        if [ "$health_status" != "healthy" ]; then
          echo "❌ アプリケーションの起動に失敗しました。"
          docker compose ps
          echo "--- 最終ログ ---"
          docker compose logs weather-bot
          exit 1
        fi
    
    - name: 9. デプロイ完了通知
      run: |
        echo "🎉 デプロイが正常に完了しました！"
        echo "------------------------------------"
        echo "  Commit: ${{ github.sha }}"
        echo "  Branch: ${{ github.ref_name }}"
        echo "  Time:   $(date '+%Y-%m-%d %H:%M:%S')"
        echo "------------------------------------"
