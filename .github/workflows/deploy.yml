name: 自動デプロイ

on:
  push:
    branches: [ main ]
  workflow_dispatch: # 手動実行を可能にする

jobs:
  deploy:
    runs-on: self-hosted # Self-Hosted Runnerを使用
    
    steps:
    - name: リポジトリをチェックアウト
      uses: actions/checkout@v4
      with:
        fetch-depth: 0 # 完全な履歴を取得（必要に応じて）
    
    - name: Docker権限とサービス状態の確認
      run: |
        echo "現在のユーザー: $(whoami)"
        echo "ユーザーグループ: $(groups)"
        
        # Dockerサービスの状態確認
        if ! systemctl is-active --quiet docker; then
          echo "Dockerサービスを開始中..."
          sudo systemctl start docker
        fi
        
        # Docker接続テスト
        if ! docker info > /dev/null 2>&1; then
          echo "Docker権限の問題を検出しました。修正を試行します..."
          
          # dockerグループに追加（既に追加されている場合はスキップ）
          if ! groups | grep -q docker; then
            sudo usermod -aG docker $(whoami)
            echo "ユーザーをdockerグループに追加しました"
          fi
          
          # Docker socketの権限確認
          if [ ! -w /var/run/docker.sock ]; then
            sudo chmod 666 /var/run/docker.sock
            echo "Docker socketの権限を修正しました"
          fi
          
          # 再テスト
          if ! docker info > /dev/null 2>&1; then
            echo "❌ Docker権限の問題が解決されませんでした"
            echo "手動で以下のスクリプトを実行してください: ./scripts/fix-docker-permissions.sh"
            exit 1
          fi
        fi
        
        echo "✅ Docker接続が正常です"
        docker --version
        docker compose version

    - name: 環境変数をシークレットから生成
      # このステップで、GitHub Actionsのシークレットから.envファイルを動的に作成します。
      # .envファイルはリポジトリにコミットしないため、この方法が安全です。
      run: |
        echo "環境変数をシークレットから.envファイルに書き込み中..."
        # シークレットに登録した環境変数名をここに記述します。
        # 例: DISCORD_TOKEN, GEMINI_API_KEY
        # GitHubリポジトリのSettings -> Secrets and variables -> Actions で設定してください。
        
        # .envファイルの内容をヒアドキュメントで書き込む
        cat << EOF > .env
        DISCORD_TOKEN=${{ secrets.DISCORD_TOKEN }}
        GEMINI_API_KEY=${{ secrets.GEMINI_API_KEY }}
        # 必要に応じて、ここに他の環境変数も追加してください
        # 例: DB_HOST=${{ secrets.DB_HOST }}
        # 例: DB_USER=${{ secrets.DB_USER }}
        # 例: DB_PASSWORD=${{ secrets.DB_PASSWORD }}
        EOF
        
        echo "✅ .envファイルが生成されました"
        # セキュリティのため、生成された.envファイルの内容はログに出力しない
        # cat .env # デバッグ時のみコメント解除
    
    - name: 既存のコンテナを停止・削除
      run: |
        echo "既存のコンテナを停止中..."
        # docker compose down は、docker-compose.ymlと同じディレクトリで実行されることを前提としています。
        # Runnerの作業ディレクトリは自動的にリポジトリのルートになります。
        docker compose down || true
        
        # 未使用のイメージとコンテナを削除
        docker system prune -f || true
    
    - name: Dockerイメージをビルド
      run: |
        echo "Dockerイメージをビルド中..."
        # .envファイルはdocker compose build時に自動的に読み込まれます。
        docker compose build --no-cache
    
    - name: アプリケーションを起動
      run: |
        echo "アプリケーションを起動中..."
        # .envファイルはdocker compose up時に自動的に読み込まれます。
        docker compose up -d
    
    - name: デプロイ状況を確認
      run: |
        echo "コンテナの状態を確認中..."
        sleep 10
        docker compose ps
        
        echo "ログを確認中..."
        # weather-bot はあなたのサービス名に置き換えてください
        docker compose logs --tail=20 weather-bot
    
    - name: ヘルスチェック
      run: |
        echo "ヘルスチェックを実行中..."
        max_attempts=30
        attempt=1
        
        while [ $attempt -le $max_attempts ]; do
          # コンテナ名が "weather-bot" であると仮定しています。
          # 実際のサービス名に合わせて調整してください。
          # "healthy" ステータスが設定されている場合はそれも確認します。
          if docker compose ps weather-bot | grep -q "healthy\|Up"; then
            echo "✅ アプリケーションが正常に起動しました！"
            break
          else
            echo "⏳ 起動を待機中... ($attempt/$max_attempts)"
            sleep 10
            attempt=$((attempt + 1))
          fi
        done
        
        if [ $attempt -gt $max_attempts ]; then
          echo "❌ アプリケーションの起動に失敗しました。"
          docker compose logs weather-bot
          exit 1
        fi
    
    - name: デプロイ完了通知
      run: |
        echo "🎉 デプロイが完了しました！"
        echo "コミット: ${{ github.sha }}"
        echo "ブランチ: ${{ github.ref_name }}"
        echo "時刻: $(date '+%Y-%m-%d %H:%M:%S')"